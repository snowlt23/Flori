
import "core/prelude"
import "core/pointer"
import "core/io"
import "core/syntax"
import "core/math"
import "core/macros"

fn get(cs CString, i Int) Char $[importjs, patternjs "$1[$2]"] {
  unref(cast[Ptr[Char]](cs) +! i)
}

fn strlen(cs CString) Int $[importc "strlen", header "string.h", importjs, patternjs "$1.length"]

macro c(s FStrLit) FExpr $[syntax] {
  len := strlen(strval(s))
  if (len != 1) {
    error(s, "char literal should be 1 length string.")
  }
  i := new_fintlit(cast[Int](get(strval(s), 0)))
  quote {
    char(`i)
  }
}

type String $[nodestruct] {
  p Ptr[Char]
  len Int
}

fn char(c Int) Char $[importjs "String.fromCharCode"] {
  cast[Char](c)
}

fn string(cs CString) String $[importjs, patternjs "$1"] {
  len := strlen(cs)
  s := init(String){alloc[Char](len + 1); len}
  memcpy(s.p, cast[Ptr[Char]](cs), len)
  unref(s.p +! len) = char(0)
  s
}
fn string(len Int) String $[importjs, patternjs "'\0'.repeat($1)"] {
  s := init(String){alloc[Char](len + 1); len}
  unref(s.p +! len) = char(0)
  s
}

fn get(s String, i Int) Char $[importjs, patternjs "$1[$2]"] {
  unref(s.p +! i)
}

macro s(s FStrLit) FExpr $[syntax] {
  quote {
    string(`s)
  }
}

fn to_cs(s String) CString $[importjs, patternjs "$1"] {
  cast[CString](s.p)
}

fn length(s String) Int $[importjs, patternjs "$1.length"] {
  s.len
}

fn push(dest ref String, src CString) $[importjs "+=", patternjs infixjs] {
  l := length(dest) + strlen(src)
  dest.p = realloc[Char](dest.p, l + 1)
  memcpy(dest.p +! length(dest), cast[Ptr[Char]](src), strlen(src))
  unref(dest.p +! l) = char(0)
  dest.len = l
}
fn push(dest ref String, src String) $[importjs "+=", patternjs infixjs] {
  l := length(dest) + length(src)
  dest.p = realloc[Char](dest.p, l + 1)
  memcpy(dest.p +! length(dest), src.p, length(src))
  unref(dest.p +! l) = char(0)
  dest.len = l
}
fn push(dest ref String, c Char) $[importjs "+=", patternjs infixjs] {
  l := length(dest) + 1
  (dest.p) = realloc[Char](dest.p, l + 1)
  unref(dest.p +! length(dest)) = c
  unref(dest.p +! l) = char(0)
  dest.len = l
}

fn print(s String) $[importjs "console.log"] {
  print(cast[CString](s.p))
}

destructor(s String) {
  dealloc(s.p)
}

fn `&(a String, b String) String $[importjs "+", patternjs infixjs] {
  ret := string("")
  push(ret, a)
  push(ret, b)
  ret
}

fn reverse(a String) String {
  ret := string("")
  for i in range(0, length(a)-1) {
    push(ret, get(a, (length(a) - i) - 1))
  }
  ret
}

fn to_s(val Int) String $[importjs, patternjs "($1).toString()"] {
  x := val
  str := string("")
  if (x == 0) {
    push(str, char(48))
  }
  while (x > 0) {
    push(str, char(48 + (x % 10)))
    x = cast[Int](x / 10)
  }
  reverse(str)
}

cr := char(13)
lf := char(10)

fn replace(s CString, dst Char, src CString) String {
  newstr := string("")
  for i in range(0, strlen(s)-1) {
    if (get(s, i) == dst) {
      push(newstr, src)
    } else {
      push(newstr, get(s, i))
    }
  }
  newstr
}
