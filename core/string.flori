import "core/prelude"
import "core/pointer"
import "core/cstring"
import "core/io"
import "core/syntax"
import "core/math"
import "core/macros"
import "core/vec"
import "core/region"
import "core/array"

struct string {
  p ^wptr[^char]
  len ^int
  cap ^int
}

const DEFAULT_CAP := 128

fn strlen(cs ^cstring) ^int $[importc "strlen", header "string.h", importjs, patternjs "$1.length"]

fn string(cs ^cstring, cap ^int) ^string $[importjs, patternjs "$1"] {
  len := strlen(cs)
  s := init(^string) {
    alloc_with[^char](cap+1)
    len
    cap
  }
  copy_memory(to_ptr(s.p), cast[^ptr[^char]](cs), len)
  unref(to_ptr(s.p) +! len) = char(0)
  s
}
fn string(cs ^cstring) ^string $[importjs, patternjs "$1"] {
  string(cs, strlen(cs)*2)
}
fn string(len ^int, cap ^int) ^string $[importjs, patternjs "'\0'.repeat($1)"] {
  s := init(^string) {
    alloc_with[^char](cap+1)
    len
    cap
  }
  unref(to_ptr(s.p) +! len) = char(0)
  s
}
fn string(len ^int) ^string $[importjs, patternjs "'\0'.repeat($1)"] {
  cap := len*2
  string(len, cap)
}

fn `!(s ^string, i ^int) ^char $[importjs, patternjs "$1[$2]"] {
  unref(to_ptr(s.p) +! i)
}

macro s(s ^fstrlit) ^fexpr $[syntax] {
  if (strlen(strval(s)) < DEFAULT_CAP) {
    quote {
      string(`s, DEFAULT_CAP)
    }
  } else {
    quote {
      string(`s)
    }
  }
}

fn to_cs(s ^string) ^cstring $[importjs, patternjs "$1"] {
  cast[^cstring](to_ptr(s.p))
}

fn length(s ^string) ^int $[importjs, patternjs "$1.length"] {
  s.len
}

fn copy(s ^string) ^string {
  string(to_cs(s))
}

fn extend(s ^ref string, size ^int) {
  if (s.len + size >= s.cap) {
    newcap := s.cap * 2
    while (s.len + size >= newcap) {
      newcap = newcap * 2
    }
    realloc(s.p, newcap + 1)
    unref(to_ptr(s.p) +! s.len) = char(0)
    s.cap = newcap
  }
}

fn push(dest ^ref string, src ^cstring) $[importjs "+=", patternjs infixjs] {
  extend(dest, strlen(src))
  l := length(dest) + strlen(src)
  copy_memory(to_ptr(dest.p) +! length(dest), cast[^ptr[^char]](src), strlen(src))
  unref(to_ptr(dest.p) +! l) = char(0)
  dest.len = l
}
fn push(dest ^ref string, src ^string) $[importjs "+=", patternjs infixjs] {
  extend(dest, length(src))
  l := length(dest) + length(src)
  copy_memory(to_ptr(dest.p) +! length(dest), to_ptr(src.p), length(src))
  unref(to_ptr(dest.p) +! l) = char(0)
  dest.len = l
}
fn push(dest ^ref string, c ^char) $[importjs "+=", patternjs infixjs] {
  extend(dest, 1)
  l := length(dest) + 1
  unref(to_ptr(dest.p) +! length(dest)) = c
  unref(to_ptr(dest.p) +! l) = char(0)
  dest.len = l
}

fn print(s ^string) $[importjs "console.log"] {
  print(cast[^cstring](to_ptr(s.p)))
}

fn `&(a ^string, b ^string) ^string $[importjs "+", patternjs infixjs] {
  ret := s""
  push(ret, a)
  push(ret, b)
  ret
}

fn reverse(a ^string) ^string {
  ret := s""
  for (i : range(0, length(a)-1)) {
    push(ret, a!(length(a) - i - 1))
  }
  ret
}

fn to_s(val ^int) ^string $[importjs, patternjs "($1).to^string()"] {
  x := val
  str := s""
  if (x == 0) {
    push(str, char(48))
  }
  while (x > 0) {
    push(str, char(48 + (x % 10)))
    x = cast[^int](x / 10)
  }
  reverse(str)
}

cr := char(13)
lf := char(10)

fn `==(a ^string, b ^string) ^bool {
  to_cs(a) == to_cs(b)
}

fn replace(s ^cstring, dst ^char, src ^cstring) ^string {
  newstr := s""
  for (i : range(0, strlen(s)-1)) {
    if (s!i == dst) {
      push(newstr, src)
    } else {
      push(newstr, s!i)
    }
  }
  newstr
}

fn split(s ^string, c ^char) ^vec[^string] {
  ret := vec[^string]()
  news := s""
  for (i : range(0, length(s)-1)) {
    if (s!i == c) {
      push(ret, news)
      news = s""
    } else {
      push(news, s!i)
    }
  }
  push(ret, news)
  ret
}

fn parse_int(cs ^cstring) ^int $[importc "atoi", header "string.h"]
fn parse_int(s ^string) ^int {
  parse_int(to_cs(s))
}

fn embed_to_template[N](s ^string, args ^array[^N, ^string]) ^string {
  ret := s""
  cnt := 0
  i := 0
  while (i < length(s)) {
    if (s!i == c"$") {
      i += 1
      if (s!i == c"$") {
        push(ret, c"$")
        i += 1
        continue()
      } elif (s!i == c"#") {
        push(ret, args!cnt)
        cnt += 1
        i += 1
      } else {
        n := cast[^int](s!i) - cast[^int](c"0")
        push(ret, args!(n-1))
        i += 1
      }
    } else {
      push(ret, s!i)
      i += 1
    }
  }
  ret
}

macro `%(s ^fexpr, args ^farray) ^fexpr {
  quote {
    embed_to_template(`s, array `args)
  }
}

# iterator items(s TExpr[^string]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`s)-1)) {
#       `element := `s!`tmp
#       `yield
#     }
#   }
# }
