
import "core/prelude"
import "core/pointer"
import "core/cstring"
import "core/io"
import "core/syntax"
import "core/math"
import "core/macros"
import "core/vec"
import "core/region"
import "core/array"

type String {
  p RPtr[Char]
  len Int
  cap Int
}

fn strlen(cs CString) Int $[importc "strlen", header "string.h", importjs, patternjs "$1.length"]

fn string(cs CString) String $[importjs, patternjs "$1"] {
  len := strlen(cs)
  cap := strlen(cs) * 2
  if (cap < 20480) {
    cap = int(20480)
  }
  var s String
  s.p = alloc[Char](cap+1)
  s.len = len
  s.cap = cap
  copy_memory(s.p.p, cast[Ptr[Char]](cs), len)
  unref(s.p.p +! len) = char(0)
  s
}
fn string(len Int, cap Int) String $[importjs, patternjs "'\0'.repeat($1)"] {
  var s String
  s.p = alloc[Char](cap + 1);
  s.len = len
  s.cap = cap;
  unref(s.p.p +! len) = char(0)
  s
}
fn string(len Int) String $[importjs, patternjs "'\0'.repeat($1)"] {
  cap := len*2
  if (cap < 1024) {
    cap = int(1024)
  }
  string(len, cap)
}

fn `!(s String, i Int) Char $[importjs, patternjs "$1[$2]"] {
  unref(s.p.p +! i)
}

macro s(s FStrLit) FExpr $[syntax] {
  quote {
    string(`s)
  }
}

fn to_cs(s String) CString $[importjs, patternjs "$1"] {
  cast[CString](s.p.p)
}

fn length(s String) Int $[importjs, patternjs "$1.length"] {
  s.len
}

fn copy(s String) String {
  string(to_cs(s))
}

fn extend(s ref String, size Int) {
  if (s.len + size >= s.cap) {
    newcap := s.cap * 2
    while (s.len + size >= newcap) {
      newcap = newcap * 2
    }
    realloc[Char](s.p, s.len, newcap + 1)
    unref(s.p.p +! s.len) = char(0)
    s.cap = newcap
  }
}

fn push(dest ref String, src CString) $[importjs "+=", patternjs infixjs] {
  extend(dest, strlen(src))
  l := length(dest) + strlen(src)
  copy_memory(dest.p.p +! length(dest), cast[Ptr[Char]](src), strlen(src))
  unref(dest.p.p +! l) = char(0)
  dest.len = l
}
fn push(dest ref String, src String) $[importjs "+=", patternjs infixjs] {
  extend(dest, length(src))
  l := length(dest) + length(src)
  copy_memory(dest.p.p +! length(dest), src.p.p, length(src))
  unref(dest.p.p +! l) = char(0)
  dest.len = l
}
fn push(dest ref String, c Char) $[importjs "+=", patternjs infixjs] {
  extend(dest, 1)
  l := length(dest) + 1
  unref(dest.p.p +! length(dest)) = c
  unref(dest.p.p +! l) = char(0)
  dest.len = l
}

fn print(s String) $[importjs "console.log"] {
  print(cast[CString](s.p.p))
}

fn `&(a String, b String) String $[importjs "+", patternjs infixjs] {
  ret := s""
  push(ret, a)
  push(ret, b)
  ret
}

fn reverse(a String) String {
  ret := s""
  for (i : range(0, length(a)-1)) {
    push(ret, a!(length(a) - i - 1))
  }
  ret
}

fn to_s(val Int) String $[importjs, patternjs "($1).toString()"] {
  x := val
  str := s""
  if (x == 0) {
    push(str, char(48))
  }
  while (x > 0) {
    push(str, char(48 + (x % 10)))
    x = cast[Int](x / 10)
  }
  reverse(str)
}

cr := char(13)
lf := char(10)

fn replace(s CString, dst Char, src CString) String {
  newstr := s""
  for (i : range(0, strlen(s)-1)) {
    if (s!i == dst) {
      push(newstr, src)
    } else {
      push(newstr, s!i)
    }
  }
  newstr
}

fn split(s String, c Char) Vec[String] {
  ret := vec[String]()
  news := s""
  for (i : range(0, length(s)-1)) {
    if (s!i == c) {
      push(ret, news)
      news = s""
    } else {
      push(news, s!i)
    }
  }
  push(ret, news)
  ret
}

fn parse_int(cs CString) Int $[importc "atoi", header "string.h"]
fn parse_int(s String) Int {
  parse_int(to_cs(s))
}

fn embed_to_template[N](s String, args Array[N, String]) String {
  ret := s""
  cnt := 0
  i := 0
  while (i < length(s)) {
    if (s!i == c"$") {
      i += 1
      if (s!i == c"$") {
        push(ret, c"$")
        i += 1
        continue()
      } elif (s!i == c"#") {
        push(ret, args!cnt)
        cnt += 1
        i += 1
      } else {
        n := cast[Int](s!i) - cast[Int](c"0")
        push(ret, args!(n-1))
        i += 1
      }
    } else {
      push(ret, s!i)
      i += 1
    }
  }
  ret
}

macro `%(s FExpr, args FArray) FExpr {
  quote {
    embed_to_template(`s, array `args)
  }
}

iterator items(s TExpr[String]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`s)-1)) {
      `element := `s!`tmp
      `yield
    }
  }
}
