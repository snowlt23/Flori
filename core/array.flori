
import "core/prelude"
import "core/io"
import "core/macros"
import "core/syntax"
import "core/string"
import "core/pointer"

type Array[N, T] $[importc, header nodeclc, declc "struct Array##1_##2 { #2 data[#1]; };", patternc "struct Array##1_##2"]

fn `![N, T](arr Array[N, T], i Int) T $[importc, header nodeclc, patternc "(($1).data[$2])"]
fn `!![N, T](arr ref Array[N, T], i Int, val T) $[importc, header nodeclc, patternc "($1)->data[$2] = $3"]
# fn rget[N, T](arr ref Array[N, T], i Int) ref T $[importc, header nodeclc, patternc "(&(($1)->data[$2]))"]
fn getref[N, T](arr ref Array[N, T]) Ptr[T] $[importc, header nodeclc, patternc "&(($1)->data[0])"]

syntax array(fexpr FExpr) FExpr {
  if (length(fexpr) != 3) {
    error(fexpr, "usage: array[N, T]()")
  }
  if (length(fexpr!1) != 2) {
    error(fexpr, "usage: array[N, T]()")
  }
  tmp := gensym()
  n := fexpr!1!0
  t := fexpr!1!1
  data := fexpr!2
  parsed := quote {
    var `tmp Array[`n, `t]
  }
  for (i : range(0, length(data)-1)) {
    fi := new_fintlit(i)
    e := data!i
    push(parsed, quote {
        set(`tmp, `fi, `e)
      })
  }
  push(parsed, tmp)
  parsed
}
