import "core/prelude"
import "core/io"
import "core/macros"
import "core/syntax"
import "core/pointer"

struct array[N, T] $[importc, header nodeclc, declc "struct Array##1_##2 { #2 data[#1]; };", patternc "struct Array##1_##2"]

fn `![N, T](arr ^array[^N, ^T], i ^int) ^T $[importc, header nodeclc, patternc "(($1).data[$2])"]
fn `!![N, T](arr ^ref array[^N, ^T], i ^int, val ^T) $[importc, header nodeclc, patternc "($1)->data[$2] = $3"]
# fn rget[N, T](arr ^ref array[^N, ^T], i Int) ^ref T $[importc, header nodeclc, patternc "(&(($1)->data[$2]))"]
fn getref[N, T](arr ^ref array[^N, ^T]) ^ptr[^T] $[importc, header nodeclc, patternc "(&(($1)->data[0]))"]
fn length[N, T](arr ^array[^N, ^T]) ^int {
  int(N)
}

macro array(elems ^tarray) ^fexpr $[syntax] {
  if (length(elems) == 0) {
    error(elems, "array should has elements.")
  }
  n := new_fintlit(length(elems))
  t := get_type(elems!0)
  tmp := gensym()
  parsed := quote {
    var `tmp ^array[^`n, ^`t]
  }
  for (i : range(0, length(elems)-1)) {
    e := elems!i
    fi := new_fintlit(i)
    push(parsed, quote {
        `tmp!`fi = `e
      })
  }
  push(parsed, tmp)
  parsed
}

iterator items[N, T](arr ^texpr[^array[^N, ^T]]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`arr)-1)) {
      `element := `arr!`tmp
      `yield
    }
  }
}
