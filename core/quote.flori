fn is_fembed(f ^fmap) ^bool {
  if is(f, FMAP_IDENT) {
    return strcmp(to_cstring(f), "fembed")
  }
  return false();
}

fn expand_fembed(f ^fmap, args ^fmap, argidx ^ptr int) {
  if is_fembed(f) {
    replace(f, get(args, *argidx))
    *argidx = *argidx + 1
  } elif is(f, FMAP_MAP) {
    flst := reverse(to_flist(f))
    i := 0
    while i < len(flst) {
      expand_fembed(get(get(flst, i), "value"), args, argidx)
      i = i+1
    }
  } elif is(f, FMAP_LIST) {
    i := 0
    while i < len(f) {
      expand_fembed(get(f, i), args, argidx)
      i = i+1
    }
  }
}
fn expand_fembed(f ^fmap, args ^fmap) ^fmap {
  retf := dup(f)
  argidx := 0
  expand_fembed(retf, args, &argidx)
  return retf
}

fn is_unquote(f ^fmap) ^bool {
  if strcmp(kind(f), FMAP_CALL) {
    return strcmp(to_cstring(get(f, "call")), "unquote")
  }
  return false()
}

fn collect_unquote(f ^fmap, args ^fmap) {
  if is_unquote(f) {
    push(args, get(get(f, "args"), 0))
    replace(f, fident("fembed"))
  } elif is(f, FMAP_MAP) {
    flst := to_flist(f)
    i := 0
    while i < len(flst) {
      collect_unquote(get(get(flst, i), "value"), args)
      i = i+1
    }
  } elif is(f, FMAP_LIST) {
    i := 0
    while i < len(f) {
      collect_unquote(get(f, i), args)
      i = i+1
    }
  }
}

fn double_unquote(f ^fmap) {
  if is_unquote(f) {
    replace(f, fcall(fident("unquote"), farg(dup(f))))
  } elif is(f, FMAP_MAP) {
    flst := to_flist(f)
    i := 0
    while i < len(flst) {
      double_unquote(get(get(flst, i), "value"))
      i = i+1
    }
  } elif is(f, FMAP_LIST) {
    i := 0
    while i < len(f) {
      double_unquote(get(f, i))
      i = i+1
    }
  }
}

macro quote_macro(f ^fmap) ^fmap {
  quotedargs := flist()
  collect_unquote(f, quotedargs)
  quotedargs = reverse(quotedargs)

  qargsym := gensym()
  retf := fblock()

  fidx := fcall(fident("cast_fmap"), farg(fintlit(cast_int(f))))
  args := flist()
  push(args, qargsym)
  push(args, fidx)
  excall := fcall(fident("expand_fembed"), args)
  push(retf, excall)
  
  i := 0
  while i < len(quotedargs) {
    args := flist()
    push(args, get(quotedargs, i))
    push(args, dup(qargsym))
    pushcall := fcall(fident("push"), args)
    push(retf, pushcall)
    i = i+1
  }

  qargs := flist()
  push(qargs, fcall(fident("flist")))
  push(qargs, dup(qargsym))
  qargdecl := fcall(fident(":="), qargs)
  push(retf, qargdecl)
  
  return retf
}

fn read_until(c ^char) ^cstring {
  p := malloc(1024)
  while true() {
    n := read_char()
    if n == c {
      *cast_ptr_char(p) = cast_char(0)
      return cast_cstring(p)
    }
    *cast_ptr_char(p) = n
    p = p+1
  }
}

syntax `() ^fmap {
  e := parse_until(*cast_ptr("`"))
  return fcall(fident("unquote"), farg(e))
}

syntax quote() ^fmap {
  body := parse()
  return fcall(fident("quote_macro"), farg(body))
}

macro fmap_as_value(f ^fmap) ^fmap {
  return fcall(fident("cast_fmap"), farg(fintlit(cast_int(f))))
}