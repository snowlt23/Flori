
import "core/prelude"
import "core/pointer"
import "core/io"
import "core/syntax"
import "core/macros"

type Vec[T] {
  data Ptr[T]
  cap Int
  len Int
}

fn vec[T](len Int, cap Int) Vec[T] {
  v := init(Vec[T]) {
    alloc[T](cap)
    cap
    len
  }
  v
}
fn vec[T](len Int) Vec[T] {
  vec[T](len, len * 2)
}
fn vec[T]() Vec[T] {
  vec[T](0, 8)
}

# syntax v(fexpr FExpr) FExpr {
#   if (length(fexpr) != 2) {
#     error(fexpr, "usage: v[...]")
#   }
#   arr := get(fexpr, 1)
#   parsed := quote {
#     := vec[]
#   }
# }

fn extend[T](v ref Vec[T]) {
  (v.data) = realloc(v.data, (v.cap)*2)
  (v.cap) = (v.cap)*2
}

fn push[T](v ref Vec[T], value T) {
  track(v -> value)
  if ((v.cap) < ((v.len)+1)) {
    extend(v)
  }
  unref((v.data) +! ((v.len) * sizeof[T]())) = value
  (v.len) += 1
}

fn length[T](v Vec[T]) Int {
  v.len
}

fn get[T](v Vec[T], i Int) T {
  unref((v.data) +! (i * sizeof[T]()))
}

destructor[T](v Vec[T]) {
  println("Vec destroyed!")
  dealloc(v.data)
}

iterator items[T](v TExpr[Vec[T]]) {
  i := gensym()
  quote {
    for `i in range(0, length(`v)-1) {
      `element := get(`v, `i)
      `yield
    }
  }
}

fn print[T](v Vec[T]) {
  print("vec[")
  if (length(v) > 0) {
    print(get(v, 0))
  }
  for i in range(1, length(v)-1) {
    print(", ")
    print(get(v, i))
  }
  print("]")
}

fn getref[T](v ref Vec[T]) Ptr[T] {
  v.data
}
