
import "core/prelude"
import "core/pointer"
import "core/io"
import "core/syntax"
import "core/macros"
import "core/dynamics"

type Vec[T] {
  data Ptr[Dynamic[T]]
  cap Int
  len Int
}

fn vec[T](len Int, cap Int) Vec[T] $[importjs, patternjs "new Array($1)"] {
  v := init(Vec[T]) {
    alloc[Dynamic[T]](cap)
    cap
    len
  }
  v
}
fn vec[T](len Int) Vec[T] {
  vec[T](len, len * 2)
}
fn vec[T]() Vec[T] {
  vec[T](0, 8)
}

macro v(t FArray, elems FList) FExpr $[syntax] {
  ret := new_fblock()
  tmp := gensym()
  push(ret, quote {
      `tmp := vec `t ()
    })
  for e in elems {
    push(ret, quote {
        push(`tmp, `e)
      })
  }
  push(ret, tmp)
  ret
}

fn extend[T](v ref Vec[T]) {
  v.data = realloc(v.data, v.cap*2)
  v.cap = v.cap*2
}

fn push[T](v ref Vec[T], value Dynamic[T]) $[importjs, patternjs "$1.push($2)"] {
  if (v.cap < v.len+1) {
    extend(v)
  }
  unref(v.data +! (v.len * sizeof[Dynamic[T]]())) = value
  v.len += 1
}
fn push[T](v ref Vec[T], value move T) $[importjs, patternjs "$1.push($2)"] {
  if (v.cap < v.len+1) {
    extend(v)
  }
  unref(v.data +! (v.len * sizeof[Dynamic[T]]())) = new_dynamic(value)
  v.len += 1
}

fn length[T](v Vec[T]) Int $[importjs, patternjs "$1.length"] {
  v.len
}

fn get[T](v Vec[T], i Int) Dynamic[T] $[importjs, patternjs "$1[$2]"] {
  unref(v.data +! (i * sizeof[Dynamic[T]]()))
}

fn set[T](v ref Vec[T], i Int, value move T) {
  when (is_share(T)) {
    p := v.data +! (i * sizeof[Dynamic[T]]())
    oldvalue := unref()
    if (unref(p).owned) {
      destruct(unref(p).data)
    }
    unref(p) = new_dynamic(value)
  }
}

iterator items[T](v TExpr[Vec[T]]) {
  i := gensym()
  quote {
    for `i in range(0, length(`v)-1) {
      `element := get(`v, `i)
      `yield
    }
  }
}

destructor[T](v Vec[T]) {
  for e in v {
    dyndestruct(e)
  }
  dealloc(v.data)
}

fn print[T](v Vec[T]) {
  print("vec[")
  if (length(v) > 0) {
    print(get(v, 0))
  }
  for i in range(1, length(v)-1) {
    print(", ")
    print(get(v, i))
  }
  print("]")
}

fn getref[T](v ref Vec[T]) Ptr[T] {
  v.data
}
