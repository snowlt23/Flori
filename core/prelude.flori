
type Void $[importc "void", header nodeclc]
type Bool $[importc "bool", header "stdbool.h"]
type StrLit $[importc "char*", header nodeclc]
type IntLit $[importc "int64_t", header "stdint.h"]
type FloatLit $[importc "double", header nodeclc]

type CString $[importc "char*", header nodeclc]
type Char $[importc "char", header nodeclc]
type CInt $[importc "int", header "stdint.h"]
type Int $[importc "int64_t", header "stdint.h"]
type Int8 $[importc "int8_t", header "stdint.h"]
type Int32 $[importc "int32_t", header "stdint.h"]
type Int64 $[importc "int64_t", header "stdint.h"]
type UInt $[importc "uint64_t", header "stdint.h"]
type UInt8 $[importc "uint8_t", header "stdint.h"]
type UInt32 $[importc "uint32_t", header "stdint.h"]
type UInt64 $[importc "uint64_t", header "stdint.h"]
type Float $[importc "float", header nodeclc]
type Double $[importc "double", header nodeclc]

fn int(x IntLit) Int $[converter, importc, patternc "$1"]
fn uint32(x IntLit) UInt32 $[converter, importc, patternc "$1"]
fn float(x FloatLit) Float $[converter, importc, patternc "$1"]
fn double(x FloatLit) Double $[converter, importc, patternc "$1"]
fn cstring(x StrLit) CString $[converter, importc, patternc "$1"]

fn `||(a Bool, b Bool) Bool $[importc "||", header nodeclc, patternc infixc, importjs "||", patternjs infixjs]
fn `&&(a Bool, b Bool) Bool $[importc "&&", header nodeclc, patternc infixc, importjs "||", patternjs infixjs]

fn `+(a Int, b Int) Int $[importc "+", header nodeclc, patternc infixc, importjs "+", patternjs infixjs]
fn `+=(a Int, b Int) $[importc "+=", header nodeclc, patternc infixc, importjs "+=", patternjs infixjs]
fn `-=(a Int, b Int) $[importc "-=", header nodeclc, patternc infixc, importjs "-=", patternjs infixjs]
fn `-(a Int, b Int) Int $[importc "-", header nodeclc, patternc infixc, importjs "-", patternjs infixjs]
fn `*(a Int, b Int) Int $[importc "*", header nodeclc, patternc infixc, importjs "*", patternjs infixjs]
fn `<<(a Int, b Int) Int $[importc "<<", header nodeclc, patternc infixc, importjs "<<", patternjs infixjs]
fn `>>(a Int, b Int) Int $[importc ">>", header nodeclc, patternc infixc, importjs ">>", patternjs infixjs]
fn `<(a Int, b Int) Bool $[importc "<", header nodeclc, patternc infixc, importjs "<", patternjs infixjs]
fn `<=(a Int, b Int) Bool $[importc "<=", header nodeclc, patternc infixc, importjs "<=", patternjs infixjs]
fn `>(a Int, b Int) Bool $[importc ">", header nodeclc, patternc infixc, importjs ">", patternjs infixjs]
fn `>=(a Int, b Int) Bool $[importc ">=", header nodeclc, patternc infixc, importjs ">=", patternjs infixjs]
fn `==(a Int, b Int) Bool $[importc "==", header nodeclc, patternc infixc, importjs "==", patternjs infixjs]
fn `!=(a Int, b Int) Bool $[importc "!=", header nodeclc, patternc infixc, importjs "!=", patternjs infixjs]

fn `==(a Char, b Char) Bool $[importc "==", header nodeclc, patternc infixc, importjs "==", patternjs infixjs]
fn `!=(a Char, b Char) Bool $[importc "!=", header nodeclc, patternc infixc, importjs "!=", patternjs infixjs]

fn `==(a UInt32, b UInt32) Bool $[importc "==", header nodeclc, patternc infixc, importjs "==", patternjs infixjs]
fn `!=(a UInt32, b UInt32) Bool $[importc "!=", header nodeclc, patternc infixc, importjs "!=", patternjs infixjs]

fn cast[T, F](val F) T $[importc, header nodeclc, patternc "((#1)($1))", importjs, patternjs "$1"]

fn `+=(a Float, b Float) $[importc "+=", header nodeclc, patternc infixc, importjs "+=", patternjs infixjs]
fn `-=(a Float, b Float) $[importc "-=", header nodeclc, patternc infixc, importjs "-=", patternjs infixjs]
fn `+(a Float, b Float) Float $[importc "+", header nodeclc, patternc infixc, importjs "+", patternjs infixjs]
fn `-(a Float, b Float) Float $[importc "-", header nodeclc, patternc infixc, importjs "-", patternjs infixjs]
fn `*(a Float, b Float) Float $[importc "*", header nodeclc, patternc infixc, importjs "*", patternjs infixjs]
fn `/(a Float, b Float) Float $[importc "/", header nodeclc, patternc infixc, importjs "/", patternjs infixjs]
fn `<(a Float, b Float) Bool $[importc "<", header nodeclc, patternc infixc, importjs "<", patternjs infixjs]
fn `<=(a Float, b Float) Bool $[importc "<=", header nodeclc, patternc infixc, importjs "<=", patternjs infixjs]
fn `>(a Float, b Float) Bool $[importc ">", header nodeclc, patternc infixc, importjs ">", patternjs infixjs]
fn `>=(a Float, b Float) Bool $[importc ">=", header nodeclc, patternc infixc, importjs ">=", patternjs infixjs]

fn `+(a Double, b Double) Double $[importc "+", header nodeclc, patternc infixc, importjs "+", patternjs infixjs]
fn `/(a Double, b Double) Double $[importc "/", header nodeclc, patternc infixc, importjs "/", patternjs infixjs]

fn `/(a Int, b Int) Double $[inline] {
  cast[Double](a) / cast[Double](b)
}

fn `<<(a UInt32, b UInt32) UInt32 $[importc "<<", header nodeclc, patternc infixc, importjs "<<", patternjs infixjs]
fn `>>(a UInt32, b UInt32) UInt32 $[importc ">>", header nodeclc, patternc infixc, importjs ">>", patternjs infixjs]

fn uint32(x Int) UInt32 $[inline] {
  cast[UInt32](x)
}
fn int(x UInt32) Int $[inline] {
  cast[Int](x)
}
fn float(x Int) Float $[inline] {
  cast[Float](x)
}
fn float(x UInt32) Float $[inline] {
  cast[Float](x)
}

fn uint8(x Int) UInt8 $[inline] {
  cast[UInt8](x)
}
fn int(x UInt8) Int $[inline] {
  cast[Int](x)
}

fn bool(x Int) Bool $[inline] {
  cast[Bool](x)
}

fn true_fn() Bool $[importc, patternc "1", importjs, patternjs "true"]
fn false_fn() Bool $[importc, patternc "0", importjs, patternjs "false"]
true := true_fn()
false := false_fn()
fn not(b Bool) Bool $[importc "!", importjs "!"]

fn break() $[importc, patternc "break"]

# string.h
fn strcmp(a CString, b CString) Int $[importc "strcmp", header "string.h", importjs "===", patternjs infixjs]
fn `==(a CString, b CString) Bool $[importjs "===", patternjs infixjs] {
  if (strcmp(a, b) == 0) {
    true
  } else {
    false
  }
}
fn `!=(a CString, b CString) Bool $[inline] {
  not(a == b)
}
