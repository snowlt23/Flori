struct storage {
  p ^pointer
  pos ^int
}

syntax buffer:() ^fmap {
  name := parse()
  size := parse()
  tsym := gensym()
  vsym := gensym()
  varf := fmap("var")
  set(varf, "name", vsym)
  set(varf, "vartype", ftype(tsym))
  namef := fmap("var")
  set(namef, "name", name)
  set(namef, "vartype", ftype(fident("storage")))
  quote {
    defprimitive `dup(tsym)` `size`
    inline fn cast_pointer(p ^ptr `dup(tsym)`) ^pointer {}
    `varf`
    `namef`
    static {
      `dup(name)`.p = cast_pointer(& `dup(vsym)`)
      `dup(name)`.pos = 0
    }
  }
}

macro <@(p ^fmap, v ^fmap) ^fmap {
  if is(p, FMAP_IDENT) {
    quote {
      buffer_at(& `p`, `v`)
    }
  } else {
    quote {
      buffer_at(`p`, `v`)
    }
  }
}

macro <@@(p ^fmap, v ^fmap) ^fmap {
  if is(p, FMAP_IDENT) {
    quote {
      buffer_at_s(& `p`, `v`)
    }
  } else {
    quote {
      buffer_at_s(`p`, `v`)
    }
  }
}

macro at(p ^fmap, t ^fmap, i ^fmap) ^fmap {
  quote {
    *cast_ptr_int(`p`.p + sizeof(`t`) * `i`)
  }
}

fn buffer_at(p ^ptr storage, v ^int) ^ptr storage {
  *cast_ptr_int(p.p + p.pos) = v
  p.pos += sizeof(^int)
  p
}

fn buffer_at(p ^ptr storage, c ^char) ^ptr storage {
  *cast_ptr_char(p.p + p.pos) = c
  p.pos += 1
  p
}

fn buffer_at(p ^ptr storage, s ^cstring) ^ptr storage {
  copy(cast_cstring(p.p + p.pos), s)
  p.pos += len(s)
  p
}

ibuf := malloc(12)
fn buffer_at_s(p ^ptr storage, x ^int) ^ptr storage {
  memset(ibuf, 0, 12)
  pos := 0
  while 0 < x {
    c := cast_char(mod(x, 10) + 48)
    *cast_ptr_char(ibuf+pos) = c
    x = x / 10
    pos += 1
  }
  for i in 0..<pos {
    buffer_at(p, *cast_ptr_char(ibuf+(pos - i - 1)))
  }
  p
}
