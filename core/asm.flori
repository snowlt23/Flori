enum register {
  rax
  rcx
  rdx
  rbx
  rsp
  rbp
  rdi
}

enum modrm_addr {
  modrm_disp_reg
  modrm_disp8
  modrm_disp32
  modrm_reg
}

# opstore := cast_ptr_char $malloc 1024
# op_i := 0

fn asmop(op ^int) {
  # internal_print op
  # opcode op
  # deref $opstore + op_i = cast_char op
  # op_i += 1
}

# fn write_opstore() {
#   for i (range0 0 op_i) {
#     opcode (cast_int (deref (opstore + op_i)))
#   }
#   op_i = 0
# }

fn modrm(rm ^register, reg ^register, md ^modrm_addr) ^int {
  cast_int(md) << 6 + cast_int(reg) << 3 + cast_int(rm)
}

fn lendian32(imm ^int) {
  asmop(imm & 0xFF)
  asmop((imm >> 8) & 0xFF)
  asmop((imm >> 16) & 0xFF)
  asmop((imm >> 24) & 0xFF)
}

fn mov(reg ^register, imm ^int) {
  asmop(0x48) asmop(0xc7) asmop(0xc0 + cast_int(reg))
  lendian32(imm)
}

fn mov(rm ^register, reg ^register) {
  asmop(0x48) asmop(0x89)
  asmop(modrm(rm, reg, modrm_reg))
}

fn push(reg ^register) {
  asmop(0x50 + cast_int(reg))
}
fn pop(reg ^register) {
  asmop(0x58 + cast_int(reg))
}

fn syscall() {
  asmop(0x0f) asmop(0x05)
}

fn ret() {
  asmop(0xc3)
}
