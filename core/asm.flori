enum register {
  rax
  rcx
  rdx
  rbx
  rsp
  rbp
  rdi
}

enum modrm_addr {
  modrm_disp_reg
  modrm_disp8
  modrm_disp32
  modrm_reg
}

fn inject_fnaddr(sym ^fmap, newidx ^int) {
  cffi(internal_inject_fnaddr_ptr, cast_int(sym), newidx)
}

fn opcode(op ^int) {
  cffi(internal_opcode_ptr, op)
}

fn asmop(op ^int) {
  opcode(op)
}

fn modrm(rm ^register, reg ^register, md ^modrm_addr) ^int {
  (cast_int(md) << 6) + (cast_int(reg) << 3) + cast_int(rm)
}

fn lendian32(imm ^int) {
  asmop(and(imm, 0xFF))
  asmop(and(imm >> 8, 0xFF))
  asmop(and(imm >> 16, 0xFF))
  asmop(and(imm >> 24, 0xFF))
}

fn mov(reg ^register, imm ^int) {
  asmop(0x48) asmop(0xc7) asmop(0xc0 + cast_int(reg))
  lendian32(imm)
}

fn mov(rm ^register, reg ^register) {
  asmop(0x48) asmop(0x89)
  asmop(modrm(rm, reg, modrm_reg))
}

fn push(reg ^register) {
  asmop(0x50 + cast_int(reg))
}
fn pop(reg ^register) {
  asmop(0x58 + cast_int(reg))
}

fn syscall() {
  asmop(0x0f) asmop(0x05)
}

fn ret() {
  asmop(0xc3)
}

fn fn_prologue() {
  push(rbp)
  mov(rbp, rsp)
}
fn fn_epilogue() {
  mov(rsp, rbp)
  pop(rbp)
  ret()
}

macro defn_macro(name ^fmap, argdecls ^fmap, body ^fmap) ^fmap {
  f := fmap("fn")
  set(f, "name", name)
  set(f, "argdecls", argdecls)
  set(f, "returntype" quote ^void)
  set(f, "body", fblock())
  semeval(f)
  sym := get(f, "sym")
  quote {
    static {
      inject_fnaddr(fmap_as_value(`sym`), get_codeidx())
      fn_prologue()
      `body`
      fn_epilogue()
    }
  }
}

syntax defn() ^fmap {
  name := parse_until(*cast_ptr("("))
  read_char()
  argdecls := flist()
  body := parse()
  quote defn_macro(`name`, `argdecls`, `body`)
}