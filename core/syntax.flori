
import "core/prelude"
import "core/macros"

fn ftype(f ^fexpr) ^fexpr $[compiletime] {
  quote{type `f}!0
}
fn ftype(s ^cstring) ^fexpr $[compiletime] {
  ftype(fident(s))
}
fn fargdecl(n ^fexpr, t ^fexpr) ^fexpr $[compiletime] {
  quote{`n `t}!0
}

syntax for(f ^fexpr) ^fexpr {
  if (kind(f) != FEXPR_SEQ || length(f) != 3 || kind(f!1) != FEXPR_LIST || length(f!1) != 1 || length(f!1!0) != 3 || to_cs(f!1!0!0) != ":") {
    error(f, "expect syntax: for (e : v) {...}")
  }

  elem := f!1!0!1
  value := f!1!0!2
  body := f!2
  
  quote {
    block {
      items(`value, `elem, `body)
    }
  }
}

syntax iterator(f ^fexpr) ^fexpr {
  if (length(f) == 4) {
    mname := f!1
    args := f!2
    body := f!3

    push(args, fargdecl(fident("element"), ftype("fexpr")))
    push(args, fargdecl(fident("yield"), ftype("fexpr")))
    
    retf := quote {
      macro `mname `args ^fexpr `body
    }
    quote {
      macro `mname `args ^fexpr `body
    }
  } elif (length(f) == 5) {
    mname := f!1
    generics := f!2
    args := f!3
    body := f!4

    push(args, fargdecl(fident("element"), ftype("fexpr")))
    push(args, fargdecl(fident("yield"), ftype("fexpr")))

    quote {
      macro `mname `generics `args ^fexpr `body
    }
  } else {
    error(f, "usage: iterator name(...) {...}")
    quote {}
  }
}

struct range {
  s ^int
  e ^int
}

fn range(s ^int, e ^int) ^range {
  init(^range){s; e}
}
iterator items(rng ^texpr[^range]) {
  quote {
    `element := `rng.s
    while (`element <= `rng.e) {
      `yield
      `element += 1
    }
  }
}

syntax when(f ^fexpr) ^fexpr {
  if (length(f) == 3) {
    tmpsym := gensym()
    cond := f!1
    body := f!2
    quote {
      syntax `tmpsym(f ^fexpr) ^fexpr {
        if `cond {
          quote `body
        } else {
          quote {}
        }
      }
      `tmpsym()
    }
  } elif (length(f) == 5) {
    if (to_cs(f!3) != "else") {
      error(f!3, "when expect `else branch.")
    }
    tmpsym := gensym()
    cond := f!1
    tbody := f!2
    fbody := f!4
    quote {
      syntax `tmpsym(f ^fexpr) ^fexpr {
        if `cond {
          quote `tbody
        } else {
          quote `fbody
        }
      }
      `tmpsym()
    }
  } else {
    error(f, "when syntax expect: when (cond) {...}")
    quote {}
  }
}

syntax static(f ^fexpr) ^fexpr {
  if (length(f) != 2) {
    error(f, "usage: static {...}")
  }
  mname := gensym()
  body := f!1
  quote {
    syntax `mname (f ^fexpr) ^fexpr {
      `body
      quote {}
    }
    `mname()
  }
}

iterator items(f ^texpr[^fexpr]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`f)-1)) {
      `element := `f!`tmp
      `yield
    }
  }
}
# iterator items(fexpr TExpr[FSeq]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`fexpr)-1)) {
#       `element := `fexpr!`tmp
#       `yield
#     }
#   }
# }
# iterator items(fexpr TExpr[FList]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`fexpr)-1)) {
#       `element := `fexpr!`tmp
#       `yield
#     }
#   }
# }
# iterator items(fexpr TExpr[FArray]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`fexpr)-1)) {
#       `element := `fexpr!`tmp
#       `yield
#     }
#   }
# }
# iterator items(fexpr TExpr[FBlock]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`fexpr)-1)) {
#       `element := `fexpr!`tmp
#       `yield
#     }
#   }
# }
# iterator items(fexpr TExpr[TSeq]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`fexpr)-1)) {
#       `element := `fexpr!`tmp
#       `yield
#     }
#   }
# }
# iterator items(fexpr TExpr[TList]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`fexpr)-1)) {
#       `element := `fexpr!`tmp
#       `yield
#     }
#   }
# }
# iterator items(fexpr TExpr[TArray]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`fexpr)-1)) {
#       `element := `fexpr!`tmp
#       `yield
#     }
#   }
# }
# iterator items(fexpr TExpr[TBlock]) {
#   tmp := gensym()
#   quote {
#     for (`tmp : range(0, length(`fexpr)-1)) {
#       `element := `fexpr!`tmp
#       `yield
#     }
#   }
# }

# FIXME: converter for macro
macro const_eval(x ^texpr[^intlit]) ^fexpr {
  tmp := gensym()
  fx := to_fexpr(x)
  quote {
    syntax `tmp(f ^fexpr) ^fexpr {
      new_fintlit(`fx)
    }
    `tmp()
  }
}

macro const_eval(x ^texpr[^int]) ^fexpr {
  tmp := gensym()
  fx := to_fexpr(x)
  quote {
    syntax `tmp(f ^fexpr) ^fexpr {
      new_fintlit(`fx)
    }
    `tmp()
  }
}

macro const_eval(s ^texpr[^cstring]) ^fexpr {
  tmp := gensym()
  fs := to_fexpr(s)
  quote {
    syntax `tmp(f ^fexpr) ^fexpr {
      new_fstrlit(`fs)
    }
    `tmp()
  }
}

macro enum(typename ^fident, body ^fblock) ^fexpr $[syntax] {
  ret := new_fblock()
  push(ret, quote {
      struct `typename $[importc "int64_t", header "stdint.h"]
      fn int(e `typename) ^int {
        cast[^int](e)
      }
      fn `==(a `typename, b `typename) ^bool {
        int(a) == int(b)
      }
      fn `!=(a `typename, b `typename) ^bool {
        int(a) != int(b)
      }
    })
  
  curr := 0
  for (i : range(0, length(body)-1)) {
    if (kind(body!i) == FEXPR_IDENT) {
      fieldname := body!i
      fieldvalue := new_fintlit(curr)
      push(ret, quote {
          `fieldname := cast[^`typename](`fieldvalue)
        })
    } elif (kind(body!i) == FEXPR_SEQ && to_cs(body!i!0) == "=") {
      fieldname := body!i!1
      fieldvalue := body!i!2
      if (kind(fieldvalue) != FEXPR_INTLIT) {
        error(fieldvalue, "unsupported enum field value.")
      }
      curr = intval(cast[^fintlit](fieldvalue))
      push(ret, quote {
          `fieldname := cast[^`typename](`fieldvalue)
        })
    } else {
      error(body!i, "unknown enum field.")
    }
    curr += 1
  }
  ret
}
