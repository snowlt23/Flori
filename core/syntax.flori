
import "core/prelude"
import "core/macros"

syntax for(fexpr FExpr) FExpr {
  if (kind(fexpr) != FEXPR_SEQ || length(fexpr) != 3 || kind(fexpr!1) != FEXPR_LIST || length(fexpr!1) != 1 || length(fexpr!1!0) != 3 || to_cs(fexpr!1!0!0) != ":") {
    error(fexpr, "expect syntax: for (e : v) {...}")
  }

  elem := fexpr!1!0!1
  value := fexpr!1!0!2
  body := fexpr!2

  quote {
    items(`value, `elem, `body)
  }
}

syntax iterator(fexpr FExpr) FExpr {
  if (length(fexpr) == 4) {
    mname := fexpr!1
    args := fexpr!2
    body := fexpr!3

    push(args, quote {element FExpr} ! 0)
    push(args, quote {yield FExpr} ! 0)
    
    quote {
      macro `mname `args FExpr `body
    }
  } elif (length(fexpr) == 5) {
    mname := fexpr!1
    generics := fexpr!2
    args := fexpr!3
    body := fexpr!4

    push(args, quote {element FExpr} ! 0)
    push(args, quote {yield FExpr} ! 0)

    quote {
      macro `mname `generics `args FExpr `body
    }
  } else {
    error(fexpr, "usage: iterator name(...) {...}")
    quote {}
  }
}

type Range {
  s Int
  e Int
}

fn range(s Int, e Int) Range {
  init(Range){s; e}
}
iterator items(range TExpr[Range]) {
  rng := cast[FExpr](range)
  quote {
    `element := `rng.s
    while (`element <= `rng.e) {
      `yield
      `element += 1
    }
  }
}

syntax when(fexpr FExpr) FExpr {
  if (length(fexpr) != 3) {
    error(fexpr, "when syntax expect: when (cond) {...}")
  }
  tmpsym := gensym()
  cond := fexpr!1
  body := fexpr!2
  quote {
    syntax `tmpsym(fexpr FExpr) FExpr {
      if `cond {
        quote `body
      } else {
        quote {}
      }
    }
    `tmpsym()
  }
}

# usage: destructor(mi MyInt) {...}
syntax destructor(fexpr FExpr) FExpr {
  if ((length(fexpr) != 3) && (length(fexpr) != 4)) {
    error(fexpr, "usage: destructor(arg1 T) {...}")
  }
  if (length(fexpr) == 3) {
    args := fexpr!1
    body := fexpr!2
    
    quote {
      fn destruct `args $[nodestruct] `body
    }
  } else {
    generics := fexpr!1
    args := fexpr!2
    body := fexpr!3
    
    quote {
      fn destruct `generics `args $[nodestruct] `body
    }
  }
}

syntax static(fexpr FExpr) FExpr {
  if (length(fexpr) != 2) {
    error(fexpr, "usage: static {...}")
  }
  mname := gensym()
  body := fexpr!1
  quote {
    syntax `mname (fexpr FExpr) FExpr {
      `body
      quote {}
    }
    `mname()
  }
}

iterator items(fexpr TExpr[FExpr]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}
iterator items(fexpr TExpr[FSeq]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}
iterator items(fexpr TExpr[FList]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}
iterator items(fexpr TExpr[FArray]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}
iterator items(fexpr TExpr[FBlock]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}
iterator items(fexpr TExpr[TSeq]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}
iterator items(fexpr TExpr[TList]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}
iterator items(fexpr TExpr[TArray]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}
iterator items(fexpr TExpr[TBlock]) {
  tmp := gensym()
  quote {
    for (`tmp : range(0, length(`fexpr)-1)) {
      `element := `fexpr!`tmp
      `yield
    }
  }
}

# FIXME: converter for macro
macro const_eval(x TExpr[IntLit]) FExpr {
  tmp := gensym()
  quote {
    syntax `tmp(fexpr FExpr) FExpr {
      new_fintlit(`x)
    }
    `tmp()
  }
}

macro const_eval(x TExpr[Int]) FExpr {
  tmp := gensym()
  quote {
    syntax `tmp(fexpr FExpr) FExpr {
      new_fintlit(`x)
    }
    `tmp()
  }
}

macro const_eval(s TExpr[CString]) FExpr {
  tmp := gensym()
  quote {
    syntax `tmp(fexpr FExpr) FExpr {
      new_fstrlit(`s)
    }
    `tmp()
  }
}
