
import "core/prelude"
import "core/io"
import "core/macros"

syntax for(fexpr FExpr) FExpr {
  if ((length(fexpr) != 5) && (length(fexpr) != 6)) {
    error(fexpr, "expect syntax: for e in iter() {...}")
  }
  
  elem := get(fexpr, 1)
  in := get(fexpr, 2)
  if (to_cs(in) != "in") {
    error(fexpr, "for-macro expect `in keyword.")
  }

  if (length(fexpr) == 6) {
    itername := get(fexpr, 3)
    iterargs := get(fexpr, 4)
    body := get(fexpr, 5)
    push(iterargs, elem)
    push(iterargs, body)
    quote {
      `itername `iterargs
    }
  } else {
    itername := new_fident("items")
    value := get(fexpr, 3)
    body := get(fexpr, 4)
    quote {
      `itername(`value, `elem, `body)
    }
  }
}

syntax iterator(fexpr FExpr) FExpr {
  if (length(fexpr) == 4) {
    mname := get(fexpr, 1)
    args := get(fexpr, 2)
    body := get(fexpr, 3)

    push(args, get(quote { element FExpr; }, 0))
    push(args, get(quote { yield FExpr; }, 0))
    
    quote {
      macro `mname `args FExpr `body
    }
  } elif (length(fexpr) == 5) {
    mname := get(fexpr, 1)
    generics := get(fexpr, 2)
    args := get(fexpr, 3)
    body := get(fexpr, 4)

    push(args, get(quote { element FExpr; }, 0))
    push(args, get(quote { yield FExpr; }, 0))

    quote {
      macro `mname `generics `args FExpr `body
    }
  } else {
    error(fexpr, "usage: iterator name(...) {...}")
    quote {}
  }
}

iterator range(start TExpr[Int], end TExpr[Int]) {
  quote {
    `element := `start
    while (`element <= `end) {
      `yield
      `element += 1
    }
  }
}

syntax when(fexpr FExpr) FExpr {
  if (length(fexpr) != 3) {
    error(fexpr, "when syntax expect: when (cond) {...}")
  }
  tmpsym := gensym()
  cond := get(fexpr, 1)
  body := get(fexpr, 2)
  quote {
    syntax `tmpsym(fexpr FExpr) FExpr {
      if `cond {
        quote `body
      } else {
        quote {}
      }
    }
    `tmpsym()
  }
}

# usage: destructor(mi MyInt) {...}
syntax destructor(fexpr FExpr) FExpr {
  if ((length(fexpr) != 3) && (length(fexpr) != 4)) {
    error(fexpr, "usage: destructor(arg1 T) {...}")
  }
  if (length(fexpr) == 3) {
    args := get(fexpr, 1)
    body := get(fexpr, 2)
    
    quote {
      fn destruct `args `body
    }
  } else {
    generics := get(fexpr, 1)
    args := get(fexpr, 2)
    body := get(fexpr, 3)
    
    quote {
      fn destruct `generics `args `body
    }
  }
}

syntax static(fexpr FExpr) FExpr {
  if (length(fexpr) != 2) {
    error(fexpr, "usage: static {...}")
  }
  mname := gensym()
  body := get(fexpr, 1)
  quote {
    syntax `mname (fexpr FExpr) FExpr {
      `body
      quote {}
    }
    `mname()
  }
}

iterator items(fexpr TExpr[FExpr]) {
  tmp := gensym()
  quote {
    for `tmp in range(0, length(`fexpr)-1) {
      `element := get(`fexpr, `tmp)
      `yield
    }
  }
}

macro const_eval(x TExpr[Int]) FExpr {
  tmp := gensym()
  quote {
    syntax `tmp(fexpr FExpr) FExpr {
      new_fintlit(`x)
    }
    `tmp()
  }
}

macro const_eval(s TExpr[CString]) FExpr {
  tmp := gensym()
  quote {
    syntax `tmp(fexpr FExpr) FExpr {
      new_fstrlit(`s)
    }
    `tmp()
  }
}
