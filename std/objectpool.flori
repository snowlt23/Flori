
import "core"

struct objectpool[t] {
  objs ^vec[^t]
}

fn new_pool[t](defaultsize ^int) ^objectpool[^t] {
  init(^objectpool[^t]) {
    vec[^t](defaultsize)
  }
}
fn new_pool[t]() ^objectpool[^t] {
  new_pool[^t](1024)
}

fn length[t](p ^objectpool[^t]) ^int {
  length(p.objs)
}

fn push[t](p ^ref objectpool[t], value ^t) {
  push(p.objs, value)
}

fn compaction[t](p ^ref objectpool[^t]) {
  vpos := 0
  for (i : range(0, length(p.objs)-1)) {
    if (islive(p.objs!i)) {
      p.objs!vpos = p.objs!i
      vpos += 1
    }
  }
  p.objs.len = vpos
}

macro use_pool(p ^flist, body ^fblock) ^fexpr $[syntax] {
  quote {
    `body
    compaction(`p)
  }
}

