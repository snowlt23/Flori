
import "core"
import "core/pointer"

type DynVec[T] $[nodestruct] {
  data Ptr[T]
  isinit Ptr[Bool]
  cap Int
  len Int
}

fn dynvec[T](len Int, cap Int) DynVec[T] {
  v := init(DynVec[T]) {
    alloc[T](cap)
    alloc[Bool](cap)
    cap
    len
  }
  for i in range(0, cap-1) {
    unref(v.isinit +! i*sizeof[Bool]()) = false
  }
  v
}
fn dynvec[T](len Int) DynVec[T] {
  dynvec[T](len, len * 2)
}
fn dynvec[T]() DynVec[T] {
  dynvec[T](0, 8)
}

fn copy[T](v DynVec[T]) DynVec[T] {
  ret := dynvec[T](v.len, v.cap)
  for i in range(0, length(v)-1) {
    set(ret, i, get(v, i))
  }
  ret
}

fn extend[T](v ref DynVec[T]) {
  v.data = realloc(v.data, v.cap*2)
  v.isinit = realloc(v.isinit, v.cap*2)
  for i in range(v.cap, v.cap*2-1) {
    unref(v.isinit +! i*sizeof[Bool]()) = false
  }
  v.cap = v.cap*2
}

fn push[T](v ref DynVec[T], value T) $[nodestruct] {
  if (v.cap < v.len+1) {
    extend(v)
  }
  if (unref(v.isinit +! (v.len * sizeof[Bool]()))) {
    destruct(unref(v.data +! (v.len * sizeof[T]())))
  }
  unref(v.data +! (v.len * sizeof[T]())) = value
  unref(v.isinit +! (v.len * sizeof[Bool]())) = true
  v.len += 1
}

fn length[T](v DynVec[T]) Int {
  v.len
}

fn get[T](v DynVec[T], i Int) T {
  unref(v.data +! (i * sizeof[T]()))
}

iterator items[T](v TExpr[DynVec[T]]) {
  i := gensym()
  quote {
    for `i in range(0, length(`v)-1) {
      `element := get(`v, `i)
      `yield
    }
  }
}

destructor[T](v DynVec[T]) {
  for i in range(0, length(v)-1) {
    if (unref(v.isinit +! i*sizeof[Bool]())) {
      destruct(get(v, i))
    }
  }
  dealloc(v.data)
  println("DynVec destroyed!")
}
