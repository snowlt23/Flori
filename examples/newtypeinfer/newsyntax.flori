
#
# examples
#

+ => $typed(int, int) internalfn("int_add")
+ => $typed(float, float) internalfn("float_add")
+ => $typed(double, double) internalfn("double_add")

# overloaded functions
add5 => $typed(int)
  x+5
add5 => $typed(float)
  x+5
add5 => $typed(double) $named(x)
  x+5
add5 => x+5 # infer: num -> num
add5 => x+5.0 # infer: float|double -> float|double

wrap => $struct(value) # infer: struct(num)
cont => $struct(value) # infer: struct(num)
add5 => x.value + 5 # infer: wrap[num]|cont[num] -> num

# template
add5 => $template
  x.value + 5
# infer: a -> b

deadcode => $const 0xDEADC0DE

reg32 => $enum(eax, ecx, edx, ebx)
s := vector(reg32.eax, reg32.ecx, reg32.edx, reg32.ebx).map(fn: tos(x)).join(", ")

storesize => $const 1024
table => $template $struct(store)
newtable => table(array(storesize))
getindex => hash(value) % storesize
! => tbl.store!getindex(value)
!! => tbl.store!getindex(value) = value

taatom => $enum:
  var(name)
  intlit(value)
tacode => $enum:
  add(left, right)
  sub(left, right)

taeval =>
  match code:
    add(left, right):
      left + right
    sub(left, right):
      left - right
# inferred =>
taeval => $typed(tacode) $return(int | float | double)
  match code:
    tacode.add(left, right):
      left + right
    tacode.sub(left, right):
      left - right

c := tacode.add(1, 2)
println(c.taeval())

ifsyntax => $syntax(if `cond `body)
ifsyntax => $syntax(if `cond `body else `elsecond `elsebody)
ifsyntax => $syntax(if `cond `body [elif `elifcond `elifbody]*)
ifsyntax => $syntax(if `cond `body [elif `elifcond `elifbody]* else `elsecond `elsebody)

fib =>
  if n<2: n
  else: fib(n-1) + fib(n-2)
wrap => $template $struct(value)
cont => $template $struct(value)
get => x.value

for => $syntax(for `elem in `iter `body)
  tmp := gensym()
  quote:
    `tmp := `iter
    `elem := next(`tmp)
    while iscont(`tmp):
      `body
      `elem = next(`tmp)

range => $struct(s, e)
.. => range(s, e)
next => r.s += 1
iscont => r.s <= r.e

vec3 => $struct(x, y, z)
+ => vec3(a.x + b.x, a.y + b.y, a.z + b.z)
- => vec3(a.x - b.x, a.y - b.y, a.z - b.z)

for i in 1..10:
  println(i)

iota =>
  v = vector()
  for i in a..b:
    v.push(i)
  v
iota(1, 10)
map =>
  ret := vector()
  for e in v:
    ret.push(call(e))
  ret

println(iota(1, 10).map(fn: i*2))

#
# syntaxes
#

# naming(infix)
name => data
# naming(infix) with metadata
name => $meta(metaargs)

# ident
x
# call
fib(x)
# ufcs call
v.push(x)
x.isprime
# infix
a + b - c
# block
call:
  line1
  line2
