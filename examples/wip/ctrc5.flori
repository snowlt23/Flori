
type Vec[T] {
  p Ptr[T]
  len Int
}

# track pragma
# dyntrack pragma

fn push[T](v ref Vec[T], value T) $[dyntrack value] {...}
fn access[T](v Vec[T]) T $[dyntrack return] {...}

fn vec_eff() Vec[File] {
  v := vec[File]()
  for (i, range(1, 10)) {
    f := open_file("test" & string(i) & ".txt")
    push(v, f)
  }
  return v
}

fn vec_main() {
  v := vec_fs() # has `v, `loop.f
  destructor(v.v); destructor(v.loop.f)
}

type VecCont {
  v Vec[File]
}

fn cont_eff() {
  return init(VecCont){vec_fs()}
}

fn cont_main() {
  
}