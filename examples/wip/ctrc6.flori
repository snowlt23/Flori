
type Vec[T] {
  p Ptr[T]
  len Int
}

fn push[T](v ref Vec[T], value T) {
  ...
  # track(v -> value)
}

fn access[T](v Vec[T], i Int) T {
  ...
  # track(return -> v)
}

#
# eff1
#

fn vec_eff() Vec[File] {
  v := vec[File]()
  for (i, range(1, 10)) {
    f := open_file("test" & string(i) & ".txt")
    push(v, f)
    # track(v -> loop.f)
  }
  return v
  # track(return -> v)
} # infer: track(return -> v) track(v -> loop.f)

fn vec_main() {
  v := vec_eff()
  destructor(v.v); destructor(v.loop.f)
}

#
# eff2
#

fn file_eff() File {
  v := vec[File]()
  for (i, range(1, 10)) {
    f := open_file("test" & string(i) & ".txt")
    push(v, f)
    # track(v -> loop.f)
  }
  sort(v)
  return access(v, 0)
  # track(return -> v)
} # infer: track(return -> v) track(v -> loop.f)

fn file_get() {
  f := file_eff()
  return f
  # track(return -> f) track(f -> v) track(v -> loop.f)
}

fn file_main() {
  f := file_get()
  println(read_line(f))
  destructor(f.v); destructor(f.loop.f)
}
