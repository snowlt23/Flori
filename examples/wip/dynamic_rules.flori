
import "core"

#
# primitives
#

type Int $[importc "int64_t", copyable]

fn copy(x Int) Int {
  x
}

type String $[copyable] {
  
}

fn copy(s String) String {
  ...
}

#
# Table
#

const TableSize := 1024

type Table[K, T] $[dynamic] {
  data Array[TableSize, dynamic T]
}

fn hash(s String) Int {
  ...
}

fn set[K, V](table ref Table[K, V], key K, value V) {
  when (is_share(T)) {
    inc(value)
  }
  get(table.data, hash(key)) = value
}

fn get[K, V](table ref Table[K, V], key K) V {
  when (is_share(T)) {
    inc(get(table.data, hash(key)))
  }
  get(table.data, hash(key))
}

fn del[K, V](table ref Table[K, V], key K) {
  when (is_unique(T)) {
    destruct(get(table.data, hash(key)))
  }
  when (is_share(T)) {
    dec(get(table.data, hash(key)))
  }
  get(table.data, hash(key)) = empty[T]()
}

#
# unique
#

type Enemy {
  name String
  hp Int
  mp Int
}

destructor(e Enemy) {
  println("Enemy destroyed!")
}

type Ctx {
  enemies Table[Enemy]
}

fn spawn_enemy(ctx ref Ctx, name String, hp Int, mp Int) {
  e := init(Enemy){name; hp; mp}
  set(ctx.vec, name, e)
}
fn spawn_enemy_get(ctx ref Ctx, name String, hp Int, mp Int) Enemy {
  e := init(Enemy){name; hp; mp}
  set(ctx.vec, name, e)
  e
}

fn kill_enemy(ctx ref Ctx, name String) {
  del(ctx.vec, name)
}

fn main() {
  ctx := init(Ctx){new_table[String, Enemy]()}
  spawn_enemy(ctx, "ZombieA", 100, 10)
  spawn_enemy(ctx, "ZombieB", 100, 10)
  ea := get_enemy(ctx, "ZombieA")
  eb := get_enemy(ctx, "ZombieB")
  kill_enemy(ctx, "ZombieA")
  kill_enemy(ctx, "ZombieB")
}
# infer =>
fn main() {
  ctx := init(Ctx){new_table[String, unique Enemy]()}
  spawn_enemy(ctx, "ZombieA", 100, 10)
  spawn_enemy(ctx, "ZombieB", 100, 10)
  ea := get_enemy(ctx, "ZombieA") # track(ea -> ctx)
  eb := get_enemy(ctx, "ZombieB") # track(ea -> eb)
  kill_enemy(ctx, "ZombieA")
  kill_enemy(ctx, "ZombieB")
}

#
# borrow
#

fn main2() {
  ctx := init(Ctx){new_table[String, Enemy]()}
  genenemies := vec[Enemy]()
  for i in range(1, 10) {
    e := spawn_enemy_get(ctx, "Zombie" & to_s(i), 100, 10)
    push(genenemies, e)
    # e not destruct, because e is sub variable
  }
}
# infer =>
fn main2() {
  ctx := init(Ctx){new_table[String, unique Enemy]()}
  genenemies := vec[borrow Enemy]()
  for i in range(1, 10) {
    e := spawn_enemy_get(ctx, "Zombie" & to_s(i), 100, 10) # track(e -> ctx)
    push(genenemies, e) # track(genenemies -> e)
  }
}

#
# sharing
#

fn main2() {
  ctx := init(Ctx){new_table[String, Enemy]()}
  genenemies := vec[Enemy]()
  for i in range(1, 10) {
    push(genenemies, init(Enemy){100, 10})
  }
  for i in range(1, 10) {
    e := spawn_enemy_get(ctx, "Zombie" & to_s(i), 100, 10)
    add_enemy(ctx, e)
    push(genenemies, e)
    # e not destruct, because e is sub variable
  }
}
# infer =>
fn main2() {
  ctx := init(Ctx){new_table[String, share Enemy]()}
  genenemies := vec[share Enemy]()
  for i in range(1, 10) {
    push(genenemies, init(Enemy){100, 10})
  }
  for i in range(1, 10) {
    e := spawn_enemy(ctx, "Zombie" & to_s(i), 100, 10)
    push(genenemies, e)
    # e not destruct, because e is borrow value
  }
}
