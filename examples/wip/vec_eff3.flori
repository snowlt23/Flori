
#
# UniqueVec
#

type UniqueVec[T] {
  p Ptr[T]
  len Int
}

fn push[T](v ref UniqueVec[T], value once T) {
  track(v -> value)
  ...
}

fn destructor[T](v UniqueVec[T]) {
  when (is_destructable(v)) {
    for i in range(0, length(v)-1) {
      destructor(get(v, i))
    }
  }
  dealloc(v.p)
}

#
# Vec
#

type Vec[T] {
  p Ptr[T]
  len Int
}

fn push[T](v ref Vec[T], value T) {
  track(v -> value)
  ...
}

fn get[T](v Vec[T], i Int) T {
  lent(return)
  ...
  
}
fn set[T](v Vec[T], i Int, value T) {
  tmpvalue := get(v, i)
  ...
}

fn destructor[T](v Vec[T]) {
  dealloc(v.p)
}

#
# eff
#

fn vec_eff() Vec {
  v := vec[File]()
  for i in range(1, 10) {
    f := open_file("test" & string(i) & ".txt")
    push(v, f)
  }
  return v
}

fn vec_get() File {
  v := vec_eff()
  f := get(v, 0)
  return f
}

fn vec_main() {
  f := vec_get()
}

file_main()

#
# expanded
#

fn vec_eff(result1 ref Vec[File], result2 ref UniqueVec[File]) {
  v := vec[File]()
  unique_loop_f := uniquevec[File]()
  for i in range(1, 10) {
    f := open_file("test" & string(i) & ".txt")
    push(v, f)
    push(unique_loop_f, f)
    track(unique_loop_f -> f)
  }

  track(v -> unique_loop_f)
  result1 = v # v.ctrc = 1
  result2 = unique_v # unique_v.ctrc = 2
}

fn vec_get(result1 ref File, result2 ref Vec[File], result3 ref Vec[File]) (File, Vec[File], UniqueVec[File]) {
  v := uninit[Vec[File]]()
  unique_loop_f := uninit[UniqueVec[File]]() # tmp
  vec_eff(v, unique_loop_f)
  f := get(v, 0)

  result1 = f # f.ctrc = 1
  result2 = v # v.ctrc = 1
  result3 = unique_loop_f # unique_loop_f.ctrc = 2
}

fn vec_main() {
  f := uninit[File]()
  v := uninit[Vec[File]]() # tmp
  unique_v := uninit[UniqueVec[File]]() # tmp
  vec_get(f, v, unique_v)
  # f.ctrc = 0
  # v.ctrc = 0, unique_loop_f.ctrc = 1
  # unique_loop_f.ctrc = 0
  # destructor(f) # illegal
  destructor(v)
  destructor(unique_loop_f)
}
