
# import

import prelude

# importc

type Void $[importc "void", header nodeclc]
type Bool $[importc "bool", header "stdbool.h"]
type CString $[importc "char*", header nodeclc]
type Int $[importc "int64_t", header "stdint.h"]
type Int32 $[importc "int32_t", header "stdint.h"]
type Int64 $[importc "int64_t", header "stdint.h"]

fn `+(a Int, b Int) Int $[importc "+", header nodeclc, pattern infixc]
fn `+=(a &Int, b Int) $[importc "+=", header nodeclc, pattern infixc]
fn `-(a Int, b Int) Int $[importc "-", header nodeclc, pattern infixc]
fn `<(a Int, b Int) Bool $[importc "<", header nodeclc, pattern infixc]
fn printf(fmt CString, x Int) $[importc "printf", header "stdio.h"]

# fib

fn fib(n Int) Int {
  if (n < 2) {
    n
  } else {
    fib(n-1) + fib(n-2)
  }
}

# vec type

type Vec[T] {
  p Ptr!Int
  len Int
}

fn new_vec[T](len Int) Vec!T {
  Vec(cast[Ptr!T](alloc(sizeof(T)*len)), len)
}

fn `![T](vec &Vec!T, index Int) &T {
  vec.p!index
}

fn push[T](vec &Vec!T, index Int, value T) {
  vec.p = realloc(vec.p, sizeof(T)*(vec.len + 1))
  vec!index = value
  vec.len += 1
}

# for macro

macro for(i FIdent, in FIdent, iter FList, body FBlock) {
  if (in != `in) {
    error(in, "for syntax: for $(name) in $(iter) {...}")
  }
  quote {
    $(append(iter!0, `_iter))($(i), $(body), $@(rest(iter)))
  }
}

macro iterator(name FIdent, args FArray, body FBlock) {
  quote {
    defmacro $(append name `_iter)$(args) $(body)
  }
}

iterator `..(i FIdent, body FBlock, a Int, b Int) {
  quote {
    $(i) := $(a)
    while ($(i) <= $(b)) $(body)
  }
}

# main

fn main() {
  top := new_vec!Int(1)
  top!0 = 9
  for i in 0..5 {
    v := new_vec!Int(1)
    v!0 = 9
    push(v, 10)
    push(v, top!0)
    top = v
  }
}

main()
