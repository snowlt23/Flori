
(require :prelude)

(deftype void {:importc :nodecl})
(deftype bool {:importc :header "stdbool.h"})
(deftype cstring {:importc "char*" :nodecl})
(deftype int {:importc "int64_t" :nodecl})
(deftype int32 {:importc "int32_t" :header "stdint.h"})
(deftype int64 {:importc "int64_t" :header "stdint.h"})

(defn + [^int a ^int b] ^int {:importc :nodecl :infix})
(defn += [^&int a ^int b] {:importc :nodecl :infix})
(defn - [^int a ^int b] ^int {:importc :nodecl :infix})
(defn < [^int a ^int b] ^bool {:importc :nodecl :infix})

(defn fib [^int n] ^int
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))

(deftype vec [:a] {:p ^(ptr :a) :len ^int})

(defn new-vec [^typedesc :a ^int len] ^(vec :a)
  (construct ^vec
    (alloc (* (sizeof :a) len)
    len)))

(defn nth {:a ^all} [^&(vec :a) vec ^int index] ^:a
  (nth (:p vec) index) value)
(defn nth-set! {:a ^all} [^&(vec :a) vec ^int index ^:a value]
  (set! (nth (:p vec) index) value))

(defn push {:a ^all} [^&(vec :a) vec ^:a value]
  (set! (:p vec) (realloc (:p vec) (* (sizeof :a) (+ (:len vec) 1))))
  (set! (nth vec (:len vec)) value)
  (+= (:len vec) 1))

(defmacro for [^fexpr i ^fexpr iter ^frest body]
  `(,(append (car iter) `-iter) ,i ,body ,@(cdr iter)))

(defmacro defiter [^fident name ^farray args ^frest body]
  `(defmacro ,(append name `-iter) ,args ,@body))

(defiter countup [^fexpr i ^fexpr body ^int a ^int b]
  `(let [,i ,a]
    (while (<= ,i ,b)
      ,body)))

(defn main []
  (let [top (new-vec ^int 1)]
    (set! (nth top 0) 9)
    (for i (countup 0 5)
      (let [v (new-vec ^int 1)]
        (set! (nth v 0) 9)
        (push v 10)
        (push v (nth top 0))
        (set! top v)))))

(main)
